#include "WinGUI.h"
#include "resource.h"
#include "blueScreen.h"

/**
 * @file WinGUI.cpp
 *
 * @author RussDev
 * GitHub: https://github.com/RussDev46
 *
 */

Window::Window()
{
	try
	{
		this->initNativeWindowObj();
		this->createNativeControls();
	}
	catch (const std::exception& e)
	{
		MessageBoxW(NULL, ExeptToWSTR(e.what()), L"Error", MB_ICONERROR | MB_OK);
		ExitProcess(EXIT_FAILURE);
	}
}

Window::~Window()
{
	FreeConsole();
}

int Window::Run()
{

	RECT _windowRC{ 0, 0, this->AppWidth, this->AppHeight };
	AdjustWindowRect(&_windowRC, WS_POPUP | WS_EX_TOPMOST, false);

	MSG _msg{};
	ShowWindow(this->hWnd, SW_SHOWDEFAULT);
	UpdateWindow(this->hWnd);
	SetWindowPos(hWnd, HWND_TOPMOST, (GetSystemMetrics(SM_CXSCREEN) - _windowRC.right) / 2, (GetSystemMetrics(SM_CYSCREEN) - _windowRC.bottom) / 2, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
	while (GetMessage(&_msg, nullptr, 0, 0))
	{
		TranslateMessage(&_msg);
		DispatchMessage(&_msg);
	}

	return static_cast<int>(_msg.wParam);

}

void Window::initNativeWindowObj()
{
	using std::runtime_error;
	using namespace std::string_literals;

	Window::hbrBackgroundColor = CreateSolidBrush(RGB(0, 0, 0));

	WNDCLASSEX _wc{ sizeof(WNDCLASSEX) };
	_wc.cbWndExtra		= 0;
	_wc.cbClsExtra		= 0;
	_wc.lpszMenuName	= NULL;
	_wc.style			= CS_HREDRAW | CS_VREDRAW;
	_wc.lpfnWndProc		= Window::applicationProc;
	_wc.hInstance		= GetModuleHandle(NULL);
	_wc.hCursor			= LoadCursor(NULL, IDC_ARROW);
	_wc.hIcon			= LoadIconA(_wc.hInstance, MAKEINTRESOURCE( IDI_ICON1));
	_wc.hIconSm			= LoadIcon(_wc.hInstance, IDI_APPLICATION);
	_wc.lpszClassName	= Window::AppClassName;
	_wc.hbrBackground	= Window::hbrBackgroundColor;

	if (!RegisterClassEx(&_wc)) {
		throw runtime_error("Error, can't register main window class"s);
	}

	RECT _windowRC{0, 0, this->AppWidth, this->AppHeight};
	AdjustWindowRect(&_windowRC,WS_POPUP | WS_EX_TOPMOST, false);

	this->hWnd = CreateWindowExW(
		0,
		this->AppClassNameW,
		this->AppName,
		WS_POPUP, 
		(GetSystemMetrics(SM_CXSCREEN) - _windowRC.right) / 2,
		(GetSystemMetrics(SM_CYSCREEN) - _windowRC.bottom) / 2,
		_windowRC.right, _windowRC.bottom, nullptr, nullptr, nullptr, this
	);

	if (!this->hWnd) {
		throw runtime_error("Error, can't create main window"s);
	}
	
}

void Window::createNativeControls()
{
	using std::runtime_error;
	using namespace std::string_literals;

	
	//Default Text "..."
	this->hfFont = CreateFont(
		60, 0, 0, 0, 0,
		FALSE, FALSE, FALSE,
		DEFAULT_CHARSET,
		OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		ANTIALIASED_QUALITY,
		DEFAULT_PITCH,
		"Segoe UI"
	);

	this->hDefaultText = CreateWindowExA(
		WS_EX_TRANSPARENT,
		"static",
		"Willst du von PenTestical gehackt werden?",
		WS_VISIBLE | WS_CHILD | SS_CENTER,
		310, 100, 550, 400,
		this->hWnd,
		reinterpret_cast<HMENU>(IDC_ID::TEXT_DEFAULT_ID),
		nullptr,
		nullptr
	);

	SendMessage(this->hDefaultText, WM_SETFONT, reinterpret_cast<WPARAM>(hfFont), TRUE);
	
	//Button "Ja"
	this->hfFont = CreateFont(
		45, 0, 0, 0,
		FW_BOLD,
		FALSE, FALSE, FALSE,
		DEFAULT_CHARSET,
		OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		ANTIALIASED_QUALITY,
		DEFAULT_PITCH,
		"Segoe UI"
	);

	this->hJaButton = CreateWindowEx(
		0,
		"button",
		"Ja",
		WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
		380, 350, 150, 70,
		this->hWnd,
		reinterpret_cast<HMENU>(IDC_ID::BUTTON_START_ID),
		nullptr,
		nullptr
	);
	
	SendMessage(this->hJaButton, WM_SETFONT, reinterpret_cast<WPARAM>(hfFont), TRUE);


	//Button "Ja"
	this->hfFont = CreateFont(
		45, 0, 0, 0,
		FW_BOLD,
		FALSE, FALSE, FALSE,
		DEFAULT_CHARSET,
		OUT_DEFAULT_PRECIS,
		CLIP_DEFAULT_PRECIS,
		ANTIALIASED_QUALITY,
		DEFAULT_PITCH,
		"Segoe UI"
	);

	this->hNeinButton = CreateWindowEx(
		0,
		"button",
		"Nein",
		WS_TABSTOP | WS_VISIBLE | WS_CHILD | BS_DEFPUSHBUTTON,
		630, 350, 150, 70,
		this->hWnd,
		reinterpret_cast<HMENU>(IDC_ID::BUTTON_START_ID),
		nullptr,
		nullptr
	);

	SendMessage(this->hNeinButton, WM_SETFONT, reinterpret_cast<WPARAM>(hfFont), TRUE);

}

LRESULT CALLBACK Window::applicationProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	Window* winGuiWindow{};

	if (uMsg == WM_NCCREATE)
	{
		winGuiWindow = static_cast<Window*>(reinterpret_cast<CREATESTRUCT*>(lParam)->lpCreateParams);
		SetLastError(0);

		if (SetWindowLongPtr(hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(winGuiWindow)) == 0)
		{
			if (GetLastError() != 0)
			{
				return FALSE;
				
			}
		}
		winGuiWindow->hWnd = hWnd;

	}
	else {
		winGuiWindow = reinterpret_cast<Window*>(GetWindowLongPtr(hWnd, GWLP_USERDATA));
	}
	
	if (winGuiWindow) {
		return winGuiWindow->windowProc(hWnd, uMsg, wParam, lParam);
	}
	
	return DefWindowProc(hWnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK Window::windowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HDC hdcStatic = NULL;

	switch (uMsg)
	{
	case WM_NCHITTEST: {
		LRESULT hit = DefWindowProc(hWnd, uMsg, wParam, lParam);
		if (hit == HTCLIENT) hit = HTCAPTION;
		return hit;
	}
	case WM_CTLCOLORSTATIC:
	{
		hdcStatic = reinterpret_cast<HDC>(wParam);

		SetTextColor(hdcStatic, RGB(255, 0, 0));
		SetBkMode(hdcStatic, TRANSPARENT);

		return reinterpret_cast<LRESULT>(GetStockObject(NULL_BRUSH));
	}
	break;
	case WM_CTLCOLORBTN:
	{
		COLORREF colorref;
		HBRUSH hBrushBtn;

		colorref = RGB(0, 0, 0);
		hBrushBtn = CreateSolidBrush(colorref);

		return reinterpret_cast<LRESULT>(hBrushBtn);
	}
	break;
	case WM_CREATE:
	{
		g_hbmBall = LoadBitmapA(GetModuleHandle(NULL), MAKEINTRESOURCEA(IDB_BITMAP1));

	}
	return 0;
	case WM_PAINT:
	{
		BITMAP bm{};
		PAINTSTRUCT ps;

		HDC hdc = BeginPaint(hWnd, &ps);
		HDC hdcMem = CreateCompatibleDC(hdc);
		
		hbmOld = reinterpret_cast<HBITMAP>(SelectObject(hdcMem, g_hbmBall));

		GetObject(g_hbmBall, sizeof(bm), &bm);
		BitBlt(hdc, -60, -30, bm.bmWidth, bm.bmHeight, hdcMem, -10, -10, SRCCOPY);
		SelectObject(hdcMem, hbmOld);
		
		DeleteDC(hdcMem);
		EndPaint(hWnd, &ps);
		
	}
	return 0;
	case WM_COMMAND:
	{
		switch (static_cast<IDC_ID>(LOWORD(wParam))) {
		case IDC_ID::BUTTON_START_ID:
			
			ShowWindow(this->hWnd, SW_HIDE);
			runMatrix();

		}
		return 0;
	}
	case WM_CLOSE:
	case WM_DESTROY:
	{
		//DeleteObject(g_hbmBall);
		//PostQuitMessage(EXIT_SUCCESS);
		return 0;
	}
	return 0;
	default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}
	return TRUE;
}

LPCWSTR Window::ExeptToWSTR(const char* exept)
{
	std::string cErrorString	= exept;
	std::wstring wErrorString	= std::wstring(cErrorString.begin(), cErrorString.end());
	LPCWSTR wstrErrorString		= wErrorString.c_str();

	return wstrErrorString;
}

void Window::skullCmd(STARTUPINFO si, PROCESS_INFORMATION pi)
{
	std::string cmd = "& title 010101010101001 & mode con:cols=60 lines=25 ";
	std::string skull = "& echo  @@@@@                                        @@@@@ & echo @@@@@@@                                      @@@@@@@ & echo @@@@@@@           @@@@@@@@@@@@@@@            @@@@@@@ & echo  @@@@@@@@       @@@@@@@@@@@@@@@@@@@        @@@@@@@@ & echo      @@@@@     @@@@@@@@@@@@@@@@@@@@@     @@@@@ & echo        @@@@@  @@@@@@@@@@@@@@@@@@@@@@@  @@@@@ & echo          @@  @@@@@@@@@@@@@@@@@@@@@@@@@  @@ & echo             @@@@@@@    @@@@@@    @@@@@@ & echo             @@@@@@      @@@@      @@@@@ & echo             @@@@@@      @@@@      @@@@@ & echo              @@@@@@    @@@@@@    @@@@@ & echo               @@@@@@@@@@@  @@@@@@@@@@ & echo                @@@@@@@@@@  @@@@@@@@@ & echo            @@   @@@@@@@@@@@@@@@@@   @@ & echo            @@@@  @@@@ @ @ @ @ @@@@  @@@@ & echo           @@@@@   @@@ @ @ @ @ @@@   @@@@@ & echo         @@@@@      @@@@@@@@@@@@@      @@@@@ & echo       @@@@          @@@@@@@@@@@          @@@@ & echo    @@@@@              @@@@@@@              @@@@@ & echo   @@@@@@@                                 @@@@@@@ & echo    @@@@@                                   @@@@@";
	std::string end = " & timeout 6 > null & exit";

	std::string a = cmd + skull + end;

	Sleep(300);
	createProcCMD(a, si, pi, true);

}

void Window::matrixCmd(STARTUPINFO si, PROCESS_INFORMATION pi)
{
	std::string cmd = "& title hacking.. & cd c:\\Windows\\ & color 0c & tree";


	std::string cmd2 = "& title hacking.. & cd c:\\ & tree & exit";

	int i;
	for (i = 0; i <= 2; i++) {
		createProcCMD(cmd, si, pi, false);
		createProcCMD(cmd2, si, pi, false);
	}
	
}

void Window::runMatrix()
{
	STARTUPINFO si;
	PROCESS_INFORMATION pi;
	ZeroMemory(&si, sizeof(si));
	si.cb = sizeof(si);
	ZeroMemory(&pi, sizeof(pi));
	si.wShowWindow = SW_SHOWDEFAULT;

	matrixCmd(si, pi);
	skullCmd(si, pi);

	BlueScreen bs;
	bs.run();
	skullCmd(si, pi);

}

void Window::createProcCMD(std::string cmd, STARTUPINFO si, PROCESS_INFORMATION pi, bool wait)
{
	std::string cmdDefault = "C:\\Windows\\system32\\cmd.exe /k  @echo off & color 0a ";

	std::string rCmd = cmdDefault + cmd;

	const char* resaltCmd = rCmd.c_str();

	if (!CreateProcessA(NULL,   
		const_cast<LPSTR>(resaltCmd),       
		NULL,          
		NULL,          
		FALSE,         
		0,             
		NULL,          
		NULL,          
		&si,           
		&pi)           
		)
	{

		return;
	}
	if(wait)
	{
		WaitForSingleObject(pi.hProcess, INFINITE); 
	}

	CloseHandle(pi.hProcess);
	CloseHandle(pi.hThread);
}
